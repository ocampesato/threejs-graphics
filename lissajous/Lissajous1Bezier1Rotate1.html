<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" >
    <title>Three.js webgl Lissajous Bezier</title>
    <meta name="viewport" 
       content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  </head>

  <body>
    <canvas id="debug" style="position:absolute; left:100px"></canvas>

    <script src="three.min.js"></script>
    <script src="stats.min.js"></script>

    <script>
      var container, stats;
      var camera, scene, renderer;
      var text, plane;
      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;
      var mouseX = 0;
      var mouseXOnMouseDown = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {
        container = document.createElement( 'div' );
        document.body.appendChild( container );

        var info = document.createElement( 'div' );
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = 'Drag to Spin';

        container.appendChild( info );

        camera = new THREE.PerspectiveCamera( 50, 
                            window.innerWidth / window.innerHeight, 
                            1, 1000 );

        camera.position.set( 0, 150, 500 );

        scene = new THREE.Scene();

        var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0, 0, 1 );
        scene.add( light );

        parent = new THREE.Object3D();
        parent.position.y = 50;
        scene.add( parent );

        function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {
          var points = shape.createPointsGeometry();
          var spacedPoints = shape.createSpacedPointsGeometry( 100 );

          // flat shape
          var geometry = new THREE.ShapeGeometry( shape );

          var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, 
                               [new THREE.MeshLambertMaterial( { color: color } ), 
                                new THREE.MeshBasicMaterial( 
                                 {color: 0x000000, wireframe: true, transparent: true}) ] );

          mesh.position.set( x, y, z - 125 );
          mesh.rotation.set( rx, ry, rz );
          mesh.scale.set( s, s, s );
          parent.add( mesh );

          // 3d shape
          var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

          var mesh = THREE.SceneUtils.createMultiMaterialObject( geometry, 
                              [new THREE.MeshLambertMaterial( { color: color } ), 
                               new THREE.MeshBasicMaterial( 
                                 {color: 0x000000, wireframe: true, transparent: true})]);

          mesh.position.set( x, y, z - 75 );
          mesh.rotation.set( rx, ry, rz );
          mesh.scale.set( s, s, s );
          parent.add( mesh );

          // solid line
          var line = new THREE.Line( points, 
                       new THREE.LineBasicMaterial( { color: color, linewidth: 2 } ) );

          line.position.set( x, y, z + 25 );
          line.rotation.set( rx, ry, rz );
          line.scale.set( s, s, s );
          parent.add( line );

          // transparent line from real points
          var line = new THREE.Line( points, 
                       new THREE.LineBasicMaterial( { color: color, opacity: 0.5 } ) );

          line.position.set( x, y, z + 75 );
          line.rotation.set( rx, ry, rz );
          line.scale.set( s, s, s );
          parent.add( line );

          // vertices from real points
          var pgeo = points.clone();
          var particles = new THREE.ParticleSystem( pgeo, 
                       new THREE.ParticleBasicMaterial( 
                           { color: color, size: 2, opacity: 0.75 } ) );

          particles.position.set( x, y, z + 75 );
          particles.rotation.set( rx, ry, rz );
          particles.scale.set( s, s, s );
          parent.add( particles );

          // transparent line from equidistance sampled points
          var line = new THREE.Line( spacedPoints, 
                       new THREE.LineBasicMaterial( { color: color, opacity: 0.2 } ) );

          line.position.set( x, y, z + 125 );
          line.rotation.set( rx, ry, rz );
          line.scale.set( s, s, s );
          parent.add( line );

          // equidistance sampled points
          var pgeo = spacedPoints.clone();
          var particles2 = new THREE.ParticleSystem( pgeo, 
                       new THREE.ParticleBasicMaterial( 
                           { color: color, size: 2, opacity: 0.5 } ) );

          particles2.position.set( x, y, z + 125 );
          particles2.rotation.set( rx, ry, rz );
          particles2.scale.set( s, s, s );
          parent.add( particles2 );
        }

        var circleRadius = 10;

        var extrudeSettings = { amount: 20 }; 
        extrudeSettings.bevelEnabled = true;
        extrudeSettings.bevelSegments = 2;
        extrudeSettings.steps = 2;

        //============ start Lissajous stuff =============
        var basePointX  = 50;
        var basePointY  = 100;
        var currentX    = 0;
        var currentY    = 0;
        var offsetX     = 0;
        var offsetY     = 0;
        var radius      = 0;
        var smallRadius = 20;
        var lineWidth   = 2;
        var spiralCount = 4;
        var A           = 200;
        var B           = 2;
        var C           = 100;
        var D           = 5;
        var angle       = 0;
        var deltaAngle  = 1;
        var maxAngle    = 20; // 721;
        var rectWidth   = 40;
        var rectHeight  = 20;
        var rx=0.0, ry=0.0, rz=0.0;
        var drx=0.01, dry=0.01, drz=1.00;
        var color=0, colors = [0xff0000, 0xffff00, 0x0000ff];
       
        for(angle=0; angle<maxAngle; angle+=deltaAngle) {
           offsetX  = A*Math.sin(B*angle*Math.PI/180);
           offsetY  = C*Math.cos(D*angle*Math.PI/180);

           currentX = basePointX+offsetX;
           currentY = basePointY-offsetY;

           // Spline shape + path extrusion
           var splinepts = [];
           splinepts.push( new THREE.Vector2 (    0+currentX,    0+currentY ) );
           splinepts.push( new THREE.Vector2 (  250+currentX,  150+currentY ) );
           splinepts.push( new THREE.Vector2 ( -100+currentX,  -50+currentY ) );
           splinepts.push( new THREE.Vector2 (  150+currentX,   50+currentY ) );

           var splineShape = new THREE.Shape();
         //splineShape.moveTo( 0, 0 );
           splineShape.moveTo( currentX/4, currentY );
           splineShape.splineThru( splinepts );

           var apath = new THREE.SplineCurve3();
           apath.points.push(new THREE.Vector3(-50+angle, 150+angle, 10+angle));
           apath.points.push(new THREE.Vector3(-20+angle, 180+angle, 20+angle));
           apath.points.push(new THREE.Vector3( 40+angle, 220+angle, 50+angle));
           apath.points.push(new THREE.Vector3(200+angle, 290+angle, 100+angle));

           color = colors[Math.floor(angle/deltaAngle) % colors.length]; 
           addShape( splineShape, extrudeSettings, 0xffff00, 
                     -250+currentX,  100+currentY, 0, rx, ry, rz, 1 );

           rx += drx; ry += dry; rz += drz;
        }

        //============ end Lissajous stuff =============

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.appendChild( renderer.domElement );

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild( stats.domElement );

        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        document.addEventListener( 'touchstart', onDocumentTouchStart, false );
        document.addEventListener( 'touchmove', onDocumentTouchMove, false );

        window.addEventListener( 'resize', onWindowResize, false );
      }

      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function onDocumentMouseDown( event ) {
        event.preventDefault();

        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
        document.addEventListener( 'mouseout', onDocumentMouseOut, false );

        mouseXOnMouseDown = event.clientX - windowHalfX;
        targetRotationOnMouseDown = targetRotation;
      }

      function onDocumentMouseMove( event ) {
        mouseX = event.clientX - windowHalfX;
        targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;
      }

      function onDocumentMouseUp( event ) {
        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
      }

      function onDocumentMouseOut( event ) {
        document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
        document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
        document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
      }

      function onDocumentTouchStart( event ) {
        if ( event.touches.length == 1 ) {
          event.preventDefault();

          mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
          targetRotationOnMouseDown = targetRotation;
        }
      }

      function onDocumentTouchMove( event ) {
        if ( event.touches.length == 1 ) {
          event.preventDefault();
          mouseX = event.touches[ 0 ].pageX - windowHalfX;
          targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
        }
      }

      function animate() {
        requestAnimationFrame( animate );

        render();
        stats.update();
      }

      function render() {
        parent.rotation.y += ( targetRotation - parent.rotation.y ) * 0.05;
        renderer.render( scene, camera );
      }
    </script>
  </body>
</html>

